<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Informer.js Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Special+Gothic:wdth@87.5&display=swap" rel="stylesheet" />
  <link href="style.css" rel="stylesheet" />
</head>

<body>
  <div class="logo">
    <img src="head-image.png" />
    <h2>Audio Analysis with</h2>
    <h1>Informer.js</h1>
  </div>
  <div id="status" class="status loading">Loading libraries...</div>

  <div class="controls">
    <h2>Audio uploader</h2>

    <div class="control-group">
      <label for="audioFile">Upload audio:</label>
      <input type="file" id="audioFile" accept="audio/*" />
    </div>

    <div class="control-group">
      <label for="fftSize">FFT and Buffer Size:</label>
      <select id="fftSize">
        <option value="1024">1024</option>
        <option value="2048">2048</option>
        <option value="4096" selected>4096</option>
        <option value="8192">8192</option>
        <option value="16384">16384</option>
      </select>
    </div>

    <button id="analyzeBtn" disabled>Analyze Audio</button>
    <button id="downloadCsvBtn" disabled>Download CSV</button>
  </div>

  <div class="descriptor-rows">
    <div id="time-descriptor-legend" class="descriptor-row">
      <strong style="color: #388e3c; margin-right: 10px">‚è±Ô∏è Time:</strong>
    </div>
    <div id="freq-descriptor-legend" class="descriptor-row">
      <strong style="color: #d32f2f; margin-right: 10px">üìä Frequency:</strong>
    </div>
  </div>
  <div class="result-section" style="margin-top: 20px; position: relative">
    <h2>üìà Analysis Results</h2>
    <div id="canvasContainer" style="
          width: 100%;
          min-height: 300px;
          background: white;
          border: 1px solid #ddd;
          border-radius: 4px;
          overflow: hidden;
        ">
      <canvas id="analysisCanvas" style="display: block; width: 100%"></canvas>
    </div>
    <div id="tooltip"></div>
  </div>

  <script src="../informer.js"></script>

  <script>
    let InformerLib = null;
    let isReady = false;

    const statusDiv = document.getElementById("status");
    const analyzeBtn = document.getElementById("analyzeBtn");
    analyzeBtn.disabled = true;
    const timeResults = document.getElementById("timeResults");
    const freqResults = document.getElementById("freqResults");
    const audioFileInput = document.getElementById("audioFile");
    const canvas = document.getElementById("analysisCanvas");
    const ctx = canvas.getContext("2d");

    // Load Informer WASM module
    InformerModule()
      .then((Module) => {
        InformerLib = Module;
        isReady = true;
        statusDiv.textContent = "‚úì Informer.js loaded and ready!";
        statusDiv.className = "status ready";
        console.log("Informer WASM library loaded successfully");
      })
      .catch((error) => {
        statusDiv.textContent = "‚úó Error loading Informer library";
        statusDiv.className = "status error";
        console.error("Failed to load Informer:", error);
      });

    // Perform FFT and get magnitudes
    // Analyze an audio buffer in overlapping chunks and visualize
    // Global state for visualization
    // Helper: Compute linear-magnitude FFT using OfflineAudioContext
    async function computeFFTMagnitudes(chunk, fftSize, sampleRate) {
      // Ensure input is Float32Array
      const float32Data = new Float32Array(chunk);
      let data;
      if (float32Data.length >= fftSize) {
        data = float32Data.slice(0, fftSize);
      } else {
        data = new Float32Array(fftSize);
        data.set(float32Data);
      }

      // Create offline context
      const OfflineAudioContext =
        window.OfflineAudioContext || window.webkitOfflineAudioContext;
      const offlineCtx = new OfflineAudioContext(1, fftSize, sampleRate);

      const audioBuffer = offlineCtx.createBuffer(1, fftSize, sampleRate);
      audioBuffer.copyToChannel(data, 0);

      const source = offlineCtx.createBufferSource();
      source.buffer = audioBuffer;

      const analyser = offlineCtx.createAnalyser();
      analyser.fftSize = fftSize;
      analyser.smoothingTimeConstant = 0;

      source.connect(analyser);
      analyser.connect(offlineCtx.destination);
      source.start(0);

      await offlineCtx.startRendering();

      // Get frequency data in dB
      const freqData = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(freqData);

      // Convert dB to linear magnitude
      const magnitudes = new Float64Array(freqData.length);
      for (let i = 0; i < freqData.length; i++) {
        if (freqData[i] < -1000) {
          magnitudes[i] = 0.0;
        } else {
          magnitudes[i] = Math.pow(10, freqData[i] / 20.0);
        }
      }
      return magnitudes;
    }

    // Analyze audio buffer and compute multiple descriptors over time
    async function analyzeAudioBuffer(audioBuffer, sampleRate, fftSize) {
      const totalSamples = audioBuffer.length;
      const hopSize = fftSize / 2;
      const numFrames = Math.max(
        1,
        Math.floor((totalSamples - fftSize) / hopSize) + 1
      );

      // Initialize descriptor arrays
      const descriptors = {};
      const descriptorRanges = {};
      for (const key of allDescriptorKeys) {
        descriptors[key] = [];
        descriptorRanges[key] = { min: Infinity, max: -Infinity };
      }

      const times = [];
      const waveform = Array.from(audioBuffer);
      const duration = totalSamples / sampleRate;
      let decodedAudioData = null;
      let originalFileName = null;

      // Create one Informer instance for the entire analysis
      const informer = new InformerLib.Informer(sampleRate, 0.85, fftSize);

      for (let i = 0; i < numFrames; i++) {
        const start = i * hopSize;
        const end = start + fftSize;
        if (end > totalSamples) break;

        const chunk = audioBuffer.slice(start, end);

        // Time domain descriptors
        informer.setBuffer(new Float64Array(chunk));
        informer.computeDescriptors(true, false);
        const timeDesc = informer.getTimeDescriptors();

        // Helper to safely push and track range
        function pushValue(key, val) {
          val = val || 0;
          descriptors[key].push(val);
          if (val < descriptorRanges[key].min)
            descriptorRanges[key].min = val;
          if (val > descriptorRanges[key].max)
            descriptorRanges[key].max = val;
        }

        // Time descriptors, with clamping where appropriate
        pushValue("peak", Math.min(1, Math.abs(timeDesc.peak || 0)));
        pushValue("rms", Math.min(1, timeDesc.rms || 0));
        pushValue("variance", Math.min(1, timeDesc.variance || 0));
        pushValue("zcr", Math.min(1, timeDesc.zerocrossing || 0));
        pushValue("skewnessTime", timeDesc.skewness || 0);
        pushValue("kurtosisTime", timeDesc.kurtosis || 0);

        // Frequency domain descriptors
        const magnitudes = await computeFFTMagnitudes(
          chunk,
          fftSize,
          sampleRate
        );
        informer.setMagnitudes(magnitudes);
        informer.computeDescriptors(false, true);
        const freqDesc = informer.getFrequencyDescriptors();

        // Frequency descriptors, with clamping where appropriate
        pushValue("centroid", freqDesc.centroid || 0);
        pushValue("peakFreq", freqDesc.peak || 0);
        pushValue("rolloff", freqDesc.rolloff || 0);
        pushValue("spread", freqDesc.spread || 0);
        pushValue(
          "flatness",
          Math.min(1, Math.max(0, freqDesc.flatness || 0))
        );
        pushValue("entropy", Math.min(1, Math.max(0, freqDesc.entropy || 0)));
        pushValue(
          "irregularity",
          Math.min(2, Math.max(0, freqDesc.irregularity || 0))
        );
        pushValue("crest", freqDesc.crestfactor || 0);
        pushValue("flux", freqDesc.flux || 0);
        pushValue("slope", freqDesc.slope || 0);
        pushValue("decrease", freqDesc.decrease || 0);
        pushValue("skewnessFreq", freqDesc.skewness || 0);
        pushValue("kurtosisFreq", freqDesc.kurtosis || 0);

        times.push(start / sampleRate);
      }

      // Clean up at the end
      informer.delete();

      // Finalize ranges
      for (const key of allDescriptorKeys) {
        if (descriptorRanges[key].min === Infinity) {
          descriptorRanges[key] = { min: 0, max: 1 };
        } else if (descriptorRanges[key].min === descriptorRanges[key].max) {
          const val = descriptorRanges[key].min;
          descriptorRanges[key].min = val - 0.1 * Math.abs(val || 1);
          descriptorRanges[key].max = val + 0.1 * Math.abs(val || 1);
        }
      }

      analysisData = {
        times,
        duration,
        sampleRate,
        waveform,
        descriptors,
        descriptorRanges,
      };
      drawAnalysis();
      renderDescriptorLegend();
    }

    // Descriptor metadata: name, min, max, unit, category
    const descriptorMeta = {
      // Time Domain
      peak: { min: 0, max: 1, unit: "", category: "time", label: "Peak" },
      rms: { min: 0, max: 1, unit: "", category: "time", label: "RMS" },
      variance: {
        min: 0,
        max: 1,
        unit: "",
        category: "time",
        label: "Variance",
      },
      zcr: {
        min: 0,
        max: 1,
        unit: "",
        category: "time",
        label: "Zero Crossing Rate",
      },
      skewnessTime: {
        min: -10,
        max: 10,
        unit: "",
        category: "time",
        label: "Skewness (Time)",
      },
      kurtosisTime: {
        min: -10,
        max: 50,
        unit: "",
        category: "time",
        label: "Kurtosis (Time)",
      },

      // Frequency Domain
      centroid: {
        min: 0,
        max: "nyquist",
        unit: "Hz",
        category: "freq",
        label: "Spectral Centroid",
      },
      peakFreq: {
        min: 0,
        max: "nyquist",
        unit: "Hz",
        category: "freq",
        label: "Spectral Peak",
      },
      rolloff: {
        min: 0,
        max: "nyquist",
        unit: "Hz",
        category: "freq",
        label: "Spectral Rolloff",
      },
      spread: {
        min: 0,
        max: "nyquist/2",
        unit: "Hz",
        category: "freq",
        label: "Spectral Spread",
      },
      flatness: {
        min: 0,
        max: 1,
        unit: "",
        category: "freq",
        label: "Spectral Flatness",
      },
      entropy: {
        min: 0,
        max: 1,
        unit: "",
        category: "freq",
        label: "Spectral Entropy",
      },
      irregularity: {
        min: 0,
        max: 2,
        unit: "",
        category: "freq",
        label: "Spectral Irregularity",
      },
      crest: {
        min: 0,
        max: 100,
        unit: "",
        category: "freq",
        label: "Crest Factor",
      },
      flux: {
        min: 0,
        max: 1000,
        unit: "",
        category: "freq",
        label: "Spectral Flux",
      },
      slope: {
        min: -1,
        max: 1,
        unit: "",
        category: "freq",
        label: "Spectral Slope",
      },
      decrease: {
        min: -1,
        max: 1,
        unit: "",
        category: "freq",
        label: "Spectral Decrease",
      },
      skewnessFreq: {
        min: -10,
        max: 10,
        unit: "",
        category: "freq",
        label: "Skewness (Freq)",
      },
      kurtosisFreq: {
        min: -10,
        max: 50,
        unit: "",
        category: "freq",
        label: "Kurtosis (Freq)",
      },
    };

    const tooltip = document.getElementById("tooltip");

    canvas.addEventListener("mousemove", handleMouseMove);
    canvas.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });

    function handleMouseMove(e) {
      if (!analysisData || visibleDescriptors.size === 0) return;

      const container = document.getElementById("canvasContainer");
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Get time from X position
      const containerWidth = container.clientWidth;
      const plotWidth = containerWidth - 60;
      const time = ((mouseX - 60) / plotWidth) * analysisData.duration;

      // Ignore if outside plot area
      if (
        mouseX < 60 ||
        mouseX > containerWidth ||
        time < 0 ||
        time > analysisData.duration
      ) {
        tooltip.style.display = "none";
        return;
      }

      // Determine which track (descriptor) is being hovered
      const visibleList = allDescriptorKeys.filter((k) =>
        visibleDescriptors.has(k)
      );
      const waveformHeight = 80;
      const trackHeight = 100;
      const topMargin = 20;

      let hoveredDescriptor = null;
      let trackIndex = -1;

      // Check descriptor tracks
      for (let i = 0; i < visibleList.length; i++) {
        const yTop = topMargin + i * trackHeight;
        const yBottom = yTop + trackHeight;
        if (mouseY >= yTop && mouseY <= yBottom) {
          hoveredDescriptor = visibleList[i];
          trackIndex = i;
          break;
        }
      }

      // Check waveform
      const waveY = topMargin + visibleList.length * trackHeight;
      const isOverWaveform =
        mouseY >= waveY && mouseY <= waveY + waveformHeight;

      // Find nearest frame index
      const times = analysisData.times;
      let frameIndex = 0;
      let minDist = Math.abs(times[0] - time);
      for (let i = 1; i < times.length; i++) {
        const dist = Math.abs(times[i] - time);
        if (dist < minDist) {
          minDist = dist;
          frameIndex = i;
        }
      }

      const actualTime = times[frameIndex];

      // Build tooltip content
      let content = `<strong>${actualTime.toFixed(3)} s</strong><br>`;

      if (hoveredDescriptor) {
        const value = analysisData.descriptors[hoveredDescriptor][frameIndex];
        const unit = descriptorMeta[hoveredDescriptor].unit;
        content += `${descriptorMeta[hoveredDescriptor].label
          }: ${value.toFixed(4)}${unit ? " " + unit : ""}`;
      } else if (isOverWaveform) {
        // Estimate waveform sample (resample)
        const waveform = analysisData.waveform;
        const sampleIndex = Math.round(
          (actualTime / analysisData.duration) * waveform.length
        );
        const sample =
          sampleIndex >= 0 && sampleIndex < waveform.length
            ? waveform[sampleIndex]
            : 0;
        content += `Waveform: ${sample.toFixed(4)}`;
      } else {
        tooltip.style.display = "none";
        return;
      }

      // Position and show tooltip
      tooltip.innerHTML = content;
      tooltip.style.left = mouseX + 10 + "px";
      tooltip.style.top = mouseY + 10 + "px";
      tooltip.style.display = "block";
    }

    const allDescriptorKeys = Object.keys(descriptorMeta);
    let analysisData = null;
    const visibleDescriptors = new Set(["centroid"]); // default

    function drawAnalysis() {
      if (!analysisData) return;

      const { times, duration, sampleRate, waveform, descriptors } =
        analysisData;

      // Get correct width from container
      const container = document.getElementById("canvasContainer");
      if (!container) return;
      const width = container.clientWidth;

      const visibleDescriptorsList = allDescriptorKeys.filter((k) =>
        visibleDescriptors.has(k)
      );
      const numTracks = visibleDescriptorsList.length;

      const waveformHeight = 80;
      const trackHeight = 100;
      const topMargin = 20;
      const bottomMargin = 20;
      const totalHeight =
        topMargin + numTracks * trackHeight + waveformHeight + bottomMargin;

      // Apply height to container
      container.style.height = totalHeight + "px";

      // Set canvas dimensions in pixels
      canvas.width = width;
      canvas.height = totalHeight;

      ctx.clearRect(0, 0, width, totalHeight);

      let currentY = topMargin;
      for (const key of visibleDescriptorsList) {
        drawTrack(
          key,
          descriptors[key],
          times,
          duration,
          sampleRate,
          currentY,
          trackHeight,
          width
        );
        currentY += trackHeight;
      }

      drawWaveform(waveform, width, totalHeight, waveformHeight, currentY);
    }

    function drawTrack(
      key,
      values,
      times,
      duration,
      sampleRate,
      y,
      height,
      width
    ) {
      const data = analysisData.descriptorRanges[key];
      let actualMin = data.min;
      let actualMax = data.max;

      // Add 5% padding to range (unless range is zero)
      if (actualMax !== actualMin) {
        const range = actualMax - actualMin;
        const padding = range * 0.05; // 5% padding
        actualMin -= padding;
        actualMax += padding;
      } else {
        // If all values are the same, create a small range
        const padding = Math.abs(actualMin) * 0.1 || 0.1;
        actualMin -= padding;
        actualMax += padding;
      }

      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, y, width, height);

      // Y-axis labels (left)
      ctx.textAlign = "right";
      ctx.fillStyle = "#555";
      ctx.font = "12px Arial";
      const minLabel = actualMin.toLocaleString(undefined, {
        maximumFractionDigits: 2,
      });
      const maxLabel = actualMax.toLocaleString(undefined, {
        maximumFractionDigits: 2,
      });
      ctx.fillText(minLabel, 55, y + height - 5); // bottom = min
      ctx.fillText(maxLabel, 55, y + 16); // top = max

      // Descriptor name (top-right)
      ctx.textAlign = "right";
      ctx.fillStyle = "#000";
      const label = descriptorMeta[key].label;
      const unit = descriptorMeta[key].unit
        ? ` (${descriptorMeta[key].unit})`
        : "";
      ctx.fillText(`${label}${unit}`, width - 10, y + 16);

      // Grid lines
      ctx.strokeStyle = "#eee";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(60, y + height);
      ctx.lineTo(width, y + height);
      ctx.moveTo(60, y + height / 2);
      ctx.lineTo(width, y + height / 2);
      ctx.moveTo(60, y);
      ctx.lineTo(width, y);
      ctx.stroke();

      // Curve, with color by category
      if (values.length > 1) {
        const color =
          descriptorMeta[key].category === "time" ? "#388E3C" : "#D32F2F";
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        const plotWidth = width - 60;
        for (let i = 0; i < times.length; i++) {
          const x = 60 + (times[i] / duration) * plotWidth;
          // Use padded range for normalization
          let norm =
            actualMax !== actualMin
              ? (values[i] - actualMin) / (actualMax - actualMin)
              : 0;
          norm = Math.max(0, Math.min(1, norm));
          const valY = y + (1 - norm) * height;
          if (i === 0) ctx.moveTo(x, valY);
          else ctx.lineTo(x, valY);
        }
        ctx.stroke();
      }

      // Border
      ctx.strokeStyle = "#ddd";
      ctx.strokeRect(0, y, width, height);
    }

    function drawWaveform(waveform, width, totalHeight, height, y) {
      ctx.fillStyle = "#fafafa";
      ctx.fillRect(0, y, width, height);

      const plotWidth = width - 60;
      ctx.strokeStyle = "#4A90E2";
      ctx.lineWidth = 1;
      ctx.beginPath();

      // ‚úÖ Explicitly map [-1, 1] to [y + height (bottom), y (top)]
      for (let i = 0; i < waveform.length; i++) {
        const x = 60 + (i / waveform.length) * plotWidth;
        // Clamp sample to [-1, 1] for safety
        const clamped = Math.max(-1, Math.min(1, waveform[i]));
        // Map: -1 ‚Üí bottom (y + height), +1 ‚Üí top (y)
        const wy = y + height - ((clamped + 1) / 2) * height;
        if (i === 0) ctx.moveTo(x, wy);
        else ctx.lineTo(x, wy);
      }
      ctx.stroke();

      // Baseline at y = 0 (center)
      ctx.strokeStyle = "#999";
      ctx.setLineDash([4, 2]);
      ctx.beginPath();
      ctx.moveTo(60, y + height / 2);
      ctx.lineTo(width, y + height / 2);
      ctx.stroke();
      ctx.setLineDash([]);

      // Y-axis labels for waveform
      ctx.textAlign = "right";
      ctx.fillStyle = "#555";
      ctx.font = "12px Arial";
      ctx.fillText("1", 55, y + 16); // top
      ctx.fillText("0", 55, y + height / 2 + 4);
      ctx.fillText("-1", 55, y + height - 4); // bottom

      // Label
      ctx.textAlign = "right";
      ctx.fillStyle = "#000";
      ctx.fillText("Waveform", width - 10, y + 16);

      ctx.strokeStyle = "#ddd";
      ctx.strokeRect(0, y, width, height);
    }

    function renderDescriptorLegend() {
      const timeContainer = document.getElementById("time-descriptor-legend");
      const freqContainer = document.getElementById("freq-descriptor-legend");

      if (!timeContainer || !freqContainer) return;

      // Clear containers
      timeContainer.innerHTML =
        '<strong style="color:#388E3C; margin-right:10px;">‚è±Ô∏è Time:</strong>';
      freqContainer.innerHTML =
        '<strong style="color:#D32F2F; margin-right:10px;">üìä Frequency:</strong>';

      allDescriptorKeys.forEach((key) => {
        const meta = descriptorMeta[key];
        const item = document.createElement("span");
        item.textContent = meta.label;
        item.style.cursor = "pointer";
        item.style.padding = "4px 8px";
        item.style.borderRadius = "4px";
        item.style.fontSize = "12px";
        item.style.fontWeight = visibleDescriptors.has(key)
          ? "bold"
          : "normal";

        const isTime = meta.category === "time";
        const activeColor = isTime ? "#388E3C" : "#D32F2F";
        const bgColor = visibleDescriptors.has(key)
          ? isTime
            ? "#e8f5e9"
            : "#ffebee"
          : "#f5f5f5";

        item.style.backgroundColor = bgColor;
        item.style.border = `1px solid ${visibleDescriptors.has(key) ? activeColor : "#ccc"
          }`;
        item.style.color = "#333";

        item.addEventListener("click", () => {
          if (visibleDescriptors.has(key)) {
            visibleDescriptors.delete(key);
          } else {
            visibleDescriptors.add(key);
          }
          drawAnalysis();
          renderDescriptorLegend();
        });

        if (isTime) {
          timeContainer.appendChild(item);
        } else {
          freqContainer.appendChild(item);
        }
      });
    }

    // Display results
    function displayResults(descriptors, elementId) {
      const element = document.getElementById(elementId);
      element.innerHTML = "";

      const entries = Object.entries(descriptors);
      if (entries.length === 0) {
        element.innerHTML = "<p>No descriptors computed</p>";
        return;
      }

      entries.forEach(([name, value]) => {
        const div = document.createElement("div");
        div.className = "descriptor";
        div.innerHTML = `
                    <span class="descriptor-name">${name}:</span>
                    <span class="descriptor-value">${value.toFixed(6)}</span>
                `;
        element.appendChild(div);
      });
    }

    // Event listener
    analyzeBtn.addEventListener("click", async () => {
      if (!decodedAudioData) {
        alert("Please upload a valid audio file first.");
        return;
      }

      const fftSize = parseInt(document.getElementById("fftSize").value);
      const { channelData, sampleRate } = decodedAudioData;

      statusDiv.textContent = "üî¨ Analyzing audio...";
      statusDiv.className = "status loading";

      try {
        await analyzeAudioBuffer(channelData, sampleRate, fftSize);
        document.getElementById('downloadCsvBtn').disabled = false;
        statusDiv.textContent = "‚úì Analysis complete!";
        statusDiv.className = "status ready";
      } catch (err) {
        statusDiv.textContent = "‚úó Analysis error: " + err.message;
        statusDiv.className = "status error";
        document.getElementById('downloadCsvBtn').disabled = true;
        console.error(err);
      }
    });

    console.log("FFT implementation loaded");

    audioFileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) {
        decodedAudioData = null;
        originalFileName = null;
        analyzeBtn.disabled = true;
        document.getElementById('downloadCsvBtn').disabled = true;
        return;
      }

      // ‚úÖ Store clean filename (without extension)
      originalFileName = file.name.replace(/\.[^/.]+$/, "");

      statusDiv.textContent = "‚úì Decoding audio file...";
      statusDiv.className = "status ready";

      try {
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const decoded = await audioContext.decodeAudioData(arrayBuffer);

        decodedAudioData = {
          channelData: decoded.getChannelData(0),
          sampleRate: decoded.sampleRate,
        };

        analyzeBtn.disabled = false;
        document.getElementById('downloadCsvBtn').disabled = true; // ‚Üê CSV not ready yet
        statusDiv.textContent = "‚úì File loaded. Click 'Analyze Audio' to proceed.";
      } catch (err) {
        decodedAudioData = null;
        originalFileName = null;
        analyzeBtn.disabled = true;
        document.getElementById('downloadCsvBtn').disabled = true;
        statusDiv.textContent = "‚úó Error decoding audio: " + err.message;
        statusDiv.className = "status error";
        console.error(err);
      }
    });

    // Download CSV button
    document.getElementById('downloadCsvBtn').addEventListener('click', () => {
      if (!analysisData) {
        alert('Please analyze audio first.');
        return;
      }

      const { times, descriptors } = analysisData;
      const fftSize = document.getElementById('fftSize').value;

      // Build CSV: header row
      let csv = 'Time,' + times.map(t => t.toFixed(6)).join(',') + '\n';

      // Add each descriptor as a row
      allDescriptorKeys.forEach(key => {
        const values = descriptors[key] || [];
        const row = times.map((_, i) => i < values.length ? values[i].toFixed(6) : '');
        csv += `"${descriptorMeta[key].label}",${row.join(',')}\n`;
      });

      // Generate filename
      const fileName = originalFileName
        ? `${originalFileName}-${fftSize}.csv`
        : `informer-analysis-${fftSize}.csv`;

      // Trigger download
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      link.click();
      URL.revokeObjectURL(link.href);
    });

    // Handle window resize (e.g. rotate phone)
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (analysisData) {
          drawAnalysis();
        }
      }, 250);
    });
  </script>
</body>

</html>